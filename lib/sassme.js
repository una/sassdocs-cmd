#! /usr/bin/env node

'use strict';

var program = require('commander');
var open = require('open');

var error = '\nUh Oh! We cant find that. Type sassme --help for a list of options!\n';

var out_nesting = 'Simple Nesting Example:\n--------------------------------------------------------\n.green {\n  color: #bada55 ;\n  .yellow-bg {\n    background: yellow;\n  }\n}\n--------------------------------------------------------\n\ncompiles to:\n--------------------------------------------------------\n.green {\n  color: #bada55;\n}\n.green .yellow-bg {\n  background: yellow;\n}\n--------------------------------------------------------\n\n for more, try sassme nested-properties or sassme nested-rules?';

var out_nestedprops = 'Nested Properties\n\nCSS has quite a few properties that are in \u201cnamespaces;\u201d for instance, font-family, font-size, and font-weight are all in the font namespace. In CSS, if you want to set a bunch of properties in the same namespace, you have to type it out each time. Sass provides a shortcut for this: just write the namespace once, then nest each of the sub-properties within it. For example:\n--------------------------------------------------------\n.funky {\n  font: {\n    family: fantasy;\n    size: 30em;\n    weight: bold;\n  }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n.funky {\n  font-family: fantasy;\n  font-size: 30em;\n  font-weight: bold; }\n--------------------------------------------------------\n\nThe property namespace itself can also have a value. For example:\n--------------------------------------------------------\n.funky {\n  font: 2px/3px {\n    family: fantasy;\n    size: 30em;\n    weight: bold;\n  }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n.funky {\n  font: 2px/3px;\n    font-family: fantasy;\n    font-size: 30em;\n    font-weight: bold; }\n--------------------------------------------------------';

var out_nestedrules = 'Nested Rules\n\nSass allows CSS rules to be nested within one another. The inner rule then only applies within the outer rule\u2019s selector. For example:\n--------------------------------------------------------\n#main p {\n  color: #00ff00;\n  width: 97%;\n\n  .redbox {\n    background-color: #ff0000;\n    color: #000000;\n  }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n#main p {\n  color: #00ff00;\n  width: 97%; }\n  #main p .redbox {\n    background-color: #ff0000;\n    color: #000000; }\n--------------------------------------------------------\n\nThis helps avoid repetition of parent selectors, and makes complex CSS layouts with lots of nested selectors much simpler. For example:\n\n--------------------------------------------------------\n#main {\n  width: 97%;\n\n  p, div {\n    font-size: 2em;\n    a { font-weight: bold; }\n  }\n\n  pre { font-size: 3em; }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n#main {\n  width: 97%; }\n  #main p, #main div {\n    font-size: 2em; }\n    #main p a, #main div a {\n      font-weight: bold; }\n  #main pre {\n    font-size: 3em; }\n--------------------------------------------------------';

var out_placeholders = 'Placeholder Selectors: %foo\n\nSass supports a special type of selector called a \u201cplaceholder selector\u201d. These look like class and id selectors, except the # or . is replaced by %. They\u2019re meant to be used with the @extend directive; for more information see @extend-Only Selectors.\n\nOn their own, without any use of @extend, rulesets that use placeholder selectors will not be rendered to CSS.';

var out_parent = 'Referencing Parent Selectors: &\n\nSometimes it\u2019s useful to use a nested rule\u2019s parent selector in other ways than the default. For instance, you might want to have special styles for when that selector is hovered over or for when the body element has a certain class. In these cases, you can explicitly specify where the parent selector should be inserted using the & character. \nFor example:\n--------------------------------------------------------\na {\n  font-weight: bold;\n  text-decoration: none;\n  &:hover { text-decoration: underline; }\n  body.firefox & { font-weight: normal; }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\na {\n  font-weight: bold;\n  text-decoration: none; }\n  a:hover {\n    text-decoration: underline; }\n  body.firefox a {\n    font-weight: normal; }\n--------------------------------------------------------\n\n& will be replaced with the parent selector as it appears in the CSS. This means that if you have a deeply nested rule, the parent selector will be fully resolved before the & is replaced. \n\nFor example:\n--------------------------------------------------------\n#main {\n  color: black;\n  a {\n    font-weight: bold;\n    &:hover { color: red; }\n  }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n#main {\n  color: black; }\n  #main a {\n    font-weight: bold; }\n    #main a:hover {\n      color: red; }\n--------------------------------------------------------\n\n& must appear at the beginning of a compound selector, but it can be followed by a suffix that will be added to the parent selector. \nFor example:\n--------------------------------------------------------\n#main {\n  color: black;\n  &-sidebar { border: 1px solid; }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n#main {\n  color: black; }\n  #main-sidebar {\n    border: 1px solid; }\n--------------------------------------------------------\n\nIf the parent selector can\u2019t have a suffix applied, Sass will throw an error.\n\n';

var out_comments = 'Comments: /* */ and //\n\nSass supports standard multiline CSS comments with /* */, as well as single-line comments with //. The multiline comments are preserved in the CSS output where possible, while the single-line comments are removed. \nFor example:\n--------------------------------------------------------\n/* This comment is\n * several lines long.\n * since it uses the CSS comment syntax,\n * it will appear in the CSS output. */\nbody { color: black; }\n\n// These comments are only one line long each.\n// They won\'t appear in the CSS output,\n// since they use the single-line comment syntax.\na { color: green; }\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n/* This comment is\n * several lines long.\n * since it uses the CSS comment syntax,\n * it will appear in the CSS output. */\nbody {\n  color: black; }\n\na {\n  color: green; }\n--------------------------------------------------------\n\nWhen the first letter of a comment is !, the comment will be interpolated and always rendered into css output even in compressed output modes. This is useful for adding Copyright notices to your generated CSS.';

var out_vars = 'Variables: $\n\nThe most straightforward way to use SassScript is to use variables. Variables begin with dollar signs, and are set like CSS properties:\n\n--------------------------------------------------------\n$width: 5em;\n--------------------------------------------------------\n\nYou can then refer to them in properties:\n\n--------------------------------------------------------\n#main {\n  width: $width;\n}\n--------------------------------------------------------';

var out_datatype = 'Data Types\n\nSassScript supports six main data types:\n\n- numbers (e.g. 1.2, 13, 10px)\n- strings of text, with and without quotes (e.g. \"foo\", \'bar\', baz)\n- colors (e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5))\n- booleans (e.g. true, false)\n- nulls (e.g. null)\n- lists of values, separated by spaces or commas (e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif)\n- maps from one value to another (e.g. (key1: value1, key2: value2))\n\nSassScript also supports all other types of CSS property value, such as Unicode ranges and !important declarations. However, it has no special handling for these types. They are treated just like unquoted strings.\n\n Search each individually.';

var out_string = 'Strings\n\nCSS specifies two kinds of strings: those with quotes, such as \"Lucida Grande\" or \'http://sass-lang.com\', and those without quotes, such as sans-serif or bold. SassScript recognizes both kinds, and in general if one kind of string is used in the Sass document, that kind of string will be used in the resulting CSS.\n\nThere is one exception to this, though: when using #{} interpolation, quoted strings are unquoted. This makes it easier to use e.g. selector names in mixins.\n\n For example:\n--------------------------------------------------------\n@mixin firefox-message($selector) {\n  body.firefox #{$selector}:before {\n    content: \"Hi, Firefox users!\";\n  }\n}\n\n@include firefox-message(\".header\");\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\nbody.firefox .header:before {\n  content: \"Hi, Firefox users!\"; }\n--------------------------------------------------------\n';

var out_list ='Lists\n\nLists are how Sass represents the values of CSS declarations like margin: 10px 15px 0 0 or font-face: Helvetica, Arial, sans-serif. Lists are just a series of other values, separated by either spaces or commas. In fact, individual values count as lists, too: theyre just lists with one item.\n\nOn their own, lists don???t do much, but the SassScript list functions make them useful. The nth function can access items in a list, the join function can join multiple lists together, and the append function can add items to lists. The @each directive can also add styles for each item in a list.\n\nIn addition to containing simple values, lists can contain other lists. For example, 1px 2px, 5px 6px is a two-item list containing the list 1px 2px and the list 5px 6px. If the inner lists have the same separator as the outer list, you???ll need to use parentheses to make it clear where the inner lists start and stop. For example, (1px 2px) (5px 6px) is also a two-item list containing the list 1px 2px and the list 5px 6px. The difference is that the outer list is space-separated, where before it was comma-separated.\n\nWhen lists are turned into plain CSS, Sass doesn???t add any parentheses, since CSS doesn???t understand them. That means that (1px 2px) (5px 6px) and 1px 2px 5px 6px will look the same when they become CSS. However, they aren???t the same when they???re Sass: the first is a list containing two lists, while the second is a list containing four numbers.\n\nLists can also have no items in them at all. These lists are represented as () (which is also an empty map). They can???t be output directly to CSS; if you try to do e.g. font-family: (), Sass will raise an error. If a list contains empty lists or null values, as in 1px 2px () 3px or 1px 2px null 3px, the empty lists and null values will be removed before the containing list is turned into CSS.\n\nComma-separated lists may have a trailing comma. This is especially useful because it allows you to represent a single-element list. For example, (1,) is a list containing 1 and (1 2 3,) is a comma-separated list containing a space-separated list containing 1, 2, and 3.';

var out_map = 'Maps\n\nMaps represent an association between keys and values, where keys are used to look up values. They make it easy to collect values into named groups and access those groups dynamically. They have no direct parallel in CSS, although they???re syntactically similar to media query expressions:\n\n--------------------------------------------------------\n$map: (key1: value1, key2: value2, key3: value3);\n--------------------------------------------------------\n\nUnlike lists, maps must always be surrounded by parentheses and must always be comma-separated. Both the keys and values in maps can be any SassScript object. A map may only have one value associated with a given key (although that value may be a list). A given value may be associated with many keys, though.\n\nLike lists, maps are mostly manipulated using SassScript functions. The map-get function looks up values in a map and the map-merge function adds values to a map. The @each directive can be used to add styles for each key/value pair in a map. The order of pairs in a map is always the same as when the map was created.\n\nMaps can also be used anywhere lists can. When used by a list function, a map is treated as a list of pairs. \n\nFor example, (key1: value1, key2: value2) would be treated as the nested list key1 value1, key2 value2 by list functions. Lists cannot be treated as maps, though, with the exception of the empty list. () represents both a map with no key/value pairs and a list with no elements.\n\nNote that map keys can be any Sass data type (even another map) and the syntax for declaring a map allows arbitrary SassScript expressions that will be evaluated to determine the key.\n\nMaps cannot be converted to plain CSS. Using one as the value of a variable or an argument to a CSS function will cause an error. Use the inspect($value) function to produce an output string useful for debugging maps.\n';

var out_color = 'Colors\n\nAny CSS color expression returns a SassScript Color value. This includes a large number of named colors which are indistinguishable from unquoted strings.\n\nIn compressed output mode, Sass will output the smallest CSS representation of a color. For example, #FF0000 will output as red in compressed mode, but blanchedalmond will output as #FFEBCD.\n\nA common issue users encounter with named colors is that since Sass prefers the same output format as was typed in other output modes, a color interpolated into a selector becomes invalid syntax when compressed. To avoid this, always quote named colors if they are meant to be used in the construction of a selector.';

var out_operation = 'Operations\n\nAll types support equality operations (== and !=). In addition, each type has its own operations that it has special support for.\n\nMore options:\n-sassme number-operations\n-sassme color-operations\n-sassme boolean-operations\n-sassme list-operations\n-sassme string-operations\n ';

var out_numberoperation = 'Number Operations\n\nSassScript supports the standard arithmetic operations on numbers (addition +, subtraction -, multiplication *, division /, and modulo %). Sass math functions preserve units during arithmetic operations. This means that, just like in real life, you cannot work on numbers with incompatible units (such as adding a number with px and em) and two numbers with the same unit that are multiplied together will produce square units (10px * 10px == 100px * px). Be Aware that px * px is an invalid CSS unit and you will get an error from Sass for attempting to use invalid units in CSS.\n\nRelational operators (<, >, <=, >=) are also supported for numbers, and equality operators (==, !=) are supported for all types.\n\nDivision and /\n\nCSS allows / to appear in property values as a way of separating numbers. Since SassScript is an extension of the CSS property syntax, it must support this, while also allowing / to be used for division. This means that by default, if two numbers are separated by / in SassScript, then they will appear that way in the resulting CSS.\n\nHowever, there are three situations where the / will be interpreted as division. These cover the vast majority of cases where division is actually used. They are:\n\nIf the value, or any part of it, is stored in a variable or returned by a function.\nIf the value is surrounded by parentheses.\nIf the value is used as part of another arithmetic expression.\n\nFor example:\n--------------------------------------------------------\np {\n  font: 10px/8px;             // Plain CSS, no division\n  $width: 1000px;\n  width: $width/2;            // Uses a variable, does division\n  width: round(1.5)/2;        // Uses a function, does division\n  height: (500px/2);          // Uses parentheses, does division\n  margin-left: 5px + 8px/2px; // Uses +, does division\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  font: 10px/8px;\n  width: 500px;\n  height: 250px;\n  margin-left: 9px; }\n--------------------------------------------------------\n\nIf you want to use variables along with a plain CSS /, you can use #{} to insert them. For example:\n\n--------------------------------------------------------\np {\n  $font-size: 12px;\n  $line-height: 30px;\n  font: #{$font-size}/#{$line-height};\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  font: 12px/30px; }\n--------------------------------------------------------';

var out_coloroperation = 'Color Operations\n\nAll arithmetic operations are supported for color values, where they work piecewise. This means that the operation is performed on the red, green, and blue components in turn. \n\nFor example:\n--------------------------------------------------------\np {\n  color: #010203 + #040506;\n}\n--------------------------------------------------------\n\ncomputes 01 + 04 = 05, 02 + 05 = 07, and 03 + 06 = 09, and is compiled to:\n--------------------------------------------------------\np {\n  color: #050709; }\nOften it\u2019s more useful to use color functions than to try to use color arithmetic to achieve the same effect.\n--------------------------------------------------------\n\nArithmetic operations also work between numbers and colors, also piecewise. For example:\n\n--------------------------------------------------------\np {\n  color: #010203 * 2;\n}\n--------------------------------------------------------\n\ncomputes 01 * 2 = 02, 02 * 2 = 04, and 03 * 2 = 06, and is compiled to:\n--------------------------------------------------------\np {\n  color: #020406; }\n--------------------------------------------------------\n\nNote that colors with an alpha channel (those created with the rgba or hsla functions) must have the same alpha value in order for color arithmetic to be done with them. The arithmetic doesn\u2019t affect the alpha value. \n\nFor example:\n--------------------------------------------------------\np {\n  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  color: rgba(255, 255, 0, 0.75); }\n--------------------------------------------------------\n\nThe alpha channel of a color can be adjusted using the opacify and transparentize functions. \n\nFor example:\n--------------------------------------------------------\n$translucent-red: rgba(255, 0, 0, 0.5);\np {\n  color: opacify($translucent-red, 0.3);\n  background-color: transparentize($translucent-red, 0.25);\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  color: rgba(255, 0, 0, 0.8);\n  background-color: rgba(255, 0, 0, 0.25); }\n--------------------------------------------------------\n\nIE filters require all colors include the alpha layer, and be in the strict format of #AABBCCDD. You can more easily convert the color using the ie_hex_str function. \n\nFor example:\n--------------------------------------------------------\n$translucent-red: rgba(255, 0, 0, 0.5);\n$green: #00ff00;\ndiv {\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled=\'false\', startColorstr=\'#{ie-hex-str($green)}\', endColorstr=\'#{ie-hex-str($translucent-red)}\');\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\ndiv {\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled=\'false\', startColorstr=#FF00FF00, endColorstr=#80FF0000);\n}\n--------------------------------------------------------';

var out_stringoperation = 'String Operations\n\nThe + operation can be used to concatenate strings:\n--------------------------------------------------------\np {\n  cursor: e + -resize;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  cursor: e-resize; }\n--------------------------------------------------------\n\nNote that if a quoted string is added to an unquoted string (that is, the quoted string is to the left of the +), the result is a quoted string. Likewise, if an unquoted string is added to a quoted string (the unquoted string is to the left of the +), the result is an unquoted string. \n\nFor example:\n--------------------------------------------------------\np:before {\n  content: \"Foo \" + Bar;\n  font-family: sans- + \"serif\";\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np:before {\n  content: \"Foo Bar\";\n  font-family: sans-serif; }\n--------------------------------------------------------\n\nBy default, if two values are placed next to one another, they are concatenated with a space:\n--------------------------------------------------------\np {\n  margin: 3px + 4px auto;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  margin: 7px auto; }\n--------------------------------------------------------\n\nWithin a string of text, #{} style interpolation can be used to place dynamic values within the string:\n\n--------------------------------------------------------\np:before {\n  content: \"I ate #{5 + 10} pies!\";\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np:before {\n  content: \"I ate 15 pies!\"; }\n--------------------------------------------------------\n\nNull values are treated as empty strings for string interpolation:\n--------------------------------------------------------\n$value: null;\np:before {\n  content: \"I ate #{$value} pies!\";\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np:before {\n  content: \"I ate  pies!\"; }\n--------------------------------------------------------';

var out_booleanoperation = 'Boolean Operations\n\nSassScript supports and, or, and not operators for boolean values.';

var out_listoperation = 'List Operations\n\nLists don\'t support any special operations. Instead, they\'re manipulated using the list functions.';

var out_parenthesis = 'Parentheses\n\nParentheses can be used to affect the order of operations:\n--------------------------------------------------------\np {\n  width: 1em + (2em * 3);\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  width: 7em; }\n--------------------------------------------------------';

var out_functions = 'Functions\n\nSassScript defines some useful functions that are called using the normal CSS function syntax:\n--------------------------------------------------------\np {\n  color: hsl(0, 100%, 50%);\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  color: #ff0000; }\n--------------------------------------------------------\n\n\nKeyword Arguments\n\nSass functions can also be called using explicit keyword arguments. The above example can also be written as:\n--------------------------------------------------------\np {\n  color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);\n}\n--------------------------------------------------------\n\nWhile this is less concise, it can make the stylesheet easier to read. It also allows functions to present more flexible interfaces, providing many arguments without becoming difficult to call.\n\nNamed arguments can be passed in any order, and arguments with default values can be omitted. Since the named arguments are variable names, underscores and dashes can be used interchangeably.';

var out_shell = 'SassScript\n\nIn addition to the plain CSS property syntax, Sass supports a small set of extensions called SassScript. SassScript allows properties to use variables, arithmetic, and extra functions. SassScript can be used in any property value.\n\nSassScript can also be used to generate selectors and property names, which is useful when writing mixins. This is done via interpolation.\n\n---\n\nInteractive Shell\n\nYou can easily experiment with SassScript using the interactive shell. To launch the shell run the sass command-line with the -i option. At the prompt, enter any legal SassScript expression to have it evaluated and the result printed out for you:\n--------------------------------------------------------\n$ sass -i\n>> \"Hello, Sassy World!\"\n\"Hello, Sassy World!\"\n>> 1px + 1px + 1px\n3px\n>> #777 + #777\n#eeeeee\n>> #777 + #888\nwhite\n--------------------------------------------------------';

var out_interpolation = 'Interpolation: \n\nYou can also use SassScript variables in selectors and property names using #{} interpolation syntax:\n--------------------------------------------------------\n$name: foo;\n$attr: border;\np.#{$name} {\n  #{$attr}-color: blue;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np.foo {\n  border-color: blue; }\n--------------------------------------------------------\n\nIt\u2019s also possible to use #{} to put SassScript into property values. In most cases this isn\u2019t any better than using a variable, but using #{} does mean that any operations near it will be treated as plain CSS. \nFor example:\n--------------------------------------------------------\np {\n  $font-size: 12px;\n  $line-height: 30px;\n  font: #{$font-size}/#{$line-height};\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  font: 12px/30px; }\n--------------------------------------------------------';

var out_default = 'Variable Defaults: !default\n\nYou can assign to variables if they aren\u2019t already assigned by adding the !default flag to the end of the value. This means that if the variable has already been assigned to, it won\u2019t be re-assigned, but if it doesn\u2019t have a value yet, it will be given one.\n\nFor example:\n--------------------------------------------------------\n$content: \"First content\";\n$content: \"Second content?\" !default;\n$new_content: \"First time reference\" !default;\n\n#main {\n  content: $content;\n  new-content: $new_content;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n#main {\n  content: \"First content\";\n  new-content: \"First time reference\"; }\nVariables with null values are treated as unassigned by !default:\n\n$content: null;\n$content: \"Non-null content\" !default;\n--------------------------------------------------------\n\n--------------------------------------------------------\n#main {\n  content: $content;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n#main {\n  content: \"Non-null content\"; }\n--------------------------------------------------------';

var out_atrules = '@-Rules and Directives\n\nSass supports all CSS3 @-rules, as well as some additional Sass-specific ones known as \u201cdirectives.\u201d These have various effects in Sass, detailed below. See also control directives and mixin directives.\n\nTry these for more info:\n- sassme @import\n- sassme @media\n- sassme @extend\n- sassme @at-root\n- sassme @debug\n- sassme @warn';

var out_atimport = '@import\n\nSass extends the CSS @import rule to allow it to import SCSS and Sass files. All imported SCSS and Sass files will be merged together into a single CSS output file. In addition, any variables or mixins defined in imported files can be used in the main file.\n\nSass looks for other Sass files in the current directory, and the Sass file directory under Rack, Rails, or Merb. Additional search directories may be specified using the :load_paths option, or the --load-path option on the command line.\n\n@import takes a filename to import. By default, it looks for a Sass file to import directly, but there are a few circumstances under which it will compile to a CSS @import rule:\n\nIf the file\u2019s extension is .css.\nIf the filename begins with http://.\nIf the filename is a url().\nIf the @import has any media queries.\nIf none of the above conditions are met and the extension is .scss or .sass, then the named Sass or SCSS file will be imported. If there is no extension, Sass will try to find a file with that name and the .scss or .sass extension and import it.\n\nFor example,\n--------------------------------------------------------\n@import \"foo.scss\";\n--------------------------------------------------------\n\nor\n\n--------------------------------------------------------\n@import \"foo\";\n--------------------------------------------------------\n\nwould both import the file foo.scss, whereas\n\n--------------------------------------------------------\n@import \"foo.css\";\n@import \"foo\" screen;\n@import \"http://foo.com/bar\";\n@import url(foo);\n--------------------------------------------------------\n\nwould all compile to\n--------------------------------------------------------\n@import \"foo.css\";\n@import \"foo\" screen;\n@import \"http://foo.com/bar\";\n@import url(foo);\n--------------------------------------------------------\n\nIt\u2019s also possible to import multiple files in one @import. For example:\n--------------------------------------------------------\n@import \"rounded-corners\", \"text-shadow\";\n--------------------------------------------------------\nwould import both the rounded-corners and the text-shadow files.\n\nImports may contain #{} interpolation, but only with certain restrictions. It\u2019s not possible to dynamically import a Sass file based on a variable; interpolation is only for CSS imports. As such, it only works with url() imports. For example:\n--------------------------------------------------------\n$family: unquote(\"Droid+Sans\");\n@import url(\"http://fonts.googleapis.com/css?family=#{$family}\");\n--------------------------------------------------------\n\nwould compile to\n--------------------------------------------------------\n@import url(\"http://fonts.googleapis.com/css?family=Droid+Sans\");\n--------------------------------------------------------\n\nFor more, try sassme @import-partials or sassme @import-nested\n';

var out_atimportpart = 'Partials\n\nIf you have a SCSS or Sass file that you want to import but don\u2019t want to compile to a CSS file, you can add an underscore to the beginning of the filename. This will tell Sass not to compile it to a normal CSS file. You can then import these files without using the underscore.\n\nFor example, you might have _colors.scss. Then no _colors.css file would be created, and you can do\n--------------------------------------------------------\n@import \"colors\";\n--------------------------------------------------------\nand _colors.scss would be imported.\n\nNote that you may not include a partial and a non-partial with the same name in the same directory. For example, _colors.scss may not exist alongside colors.scss.\n\n';

var out_atimportnest = 'Nested @import\n\nAlthough most of the time it\u2019s most useful to just have @imports at the top level of the document, it is possible to include them within CSS rules and @media rules. Like a base-level @import, this includes the contents of the @imported file. However, the imported rules will be nested in the same place as the original @import.\n\nFor example, if example.scss contains\n--------------------------------------------------------\n.example {\n  color: red;\n}\n--------------------------------------------------------\n\nthen\n--------------------------------------------------------\n#main {\n  @import \"example\";\n}\n--------------------------------------------------------\n\nwould compile to:\n--------------------------------------------------------\n#main .example {\n  color: red;\n}\n--------------------------------------------------------\n\nDirectives that are only allowed at the base level of a document, like @mixin or @charset, are not allowed in files that are @imported in a nested context.\n\nIt\u2019s not possible to nest @import within mixins or control directives.';

var out_atmedia = '@media\n\n@media directives in Sass behave just like they do in plain CSS, with one extra capability: they can be nested in CSS rules. If a @media directive appears within a CSS rule, it will be bubbled up to the top level of the stylesheet, putting all the selectors on the way inside the rule. This makes it easy to add media-specific styles without having to repeat selectors or break the flow of the stylesheet. For example:\n--------------------------------------------------------\n.sidebar {\n  width: 300px;\n  @media screen and (orientation: landscape) {\n    width: 500px;\n  }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n.sidebar {\n  width: 300px; }\n  @media screen and (orientation: landscape) {\n    .sidebar {\n      width: 500px; } }\n--------------------------------------------------------\n\n@media queries can also be nested within one another. The queries will then be combined using the and operator. \nFor example:\n--------------------------------------------------------\n@media screen {\n  .sidebar {\n    @media (orientation: landscape) {\n      width: 500px;\n    }\n  }\n}--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n@media screen and (orientation: landscape) {\n  .sidebar {\n    width: 500px; } }\n--------------------------------------------------------\n\nFinally, @media queries can contain SassScript expressions (including variables, functions, and operators) in place of the feature names and feature values. \n\nFor example:\n--------------------------------------------------------\n$media: screen;\n$feature: -webkit-min-device-pixel-ratio;\n$value: 1.5;\n\n@media #{$media} and ($feature: $value) {\n  .sidebar {\n    width: 500px;\n  }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n@media screen and (-webkit-min-device-pixel-ratio: 1.5) {\n  .sidebar {\n    width: 500px; } }\n--------------------------------------------------------';

var out_atextend = '@extend\n\nThere are often cases when designing a page when one class should have all the styles of another class, as well as its own specific styles. The most common way of handling this is to use both the more general class and the more specific class in the HTML. For example, suppose we have a design for a normal error and also for a serious error. We might write our markup like so:\n\n--------------------------------------------------------\n<div class=\"error seriousError\">\n  Oh no! You\'ve been hacked!\n</div>\n--------------------------------------------------------\n\nAnd our styles like so:\n--------------------------------------------------------\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.seriousError {\n  border-width: 3px;\n}\n--------------------------------------------------------\n\nUnfortunately, this means that we have to always remember to use .error with .seriousError. This is a maintenance burden, leads to tricky bugs, and can bring non-semantic style concerns into the markup.\n\nThe @extend directive avoids these problems by telling Sass that one selector should inherit the styles of another selector. \nFor example:\n--------------------------------------------------------\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\nis compiled to:\n\n.error, .seriousError {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n\n.seriousError {\n  border-width: 3px;\n}\n--------------------------------------------------------\n\nThis means that all styles defined for .error are also applied to .seriousError, in addition to the styles specific to .seriousError. In effect, every element with class .seriousError also has class .error.\n\nOther rules that use .error will work for .seriousError as well. For example, if we have special styles for errors caused by hackers:\n--------------------------------------------------------\n.error.intrusion {\n  background-image: url(\"/image/hacked.png\");\n}\n--------------------------------------------------------\n\nThen <div class=\"seriousError intrusion\"> will have the hacked.png background image as well.\n\nHow it Works\n\n@extend works by inserting the extending selector (e.g. .seriousError) anywhere in the stylesheet that the extended selector (.e.g .error) appears. Thus the example:\n\n--------------------------------------------------------\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.error.intrusion {\n  background-image: url(\"/image/hacked.png\");\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n.error, .seriousError {\n  border: 1px #f00;\n  background-color: #fdd; }\n\n.error.intrusion, .seriousError.intrusion {\n  background-image: url(\"/image/hacked.png\"); }\n\n.seriousError {\n  border-width: 3px; }\n--------------------------------------------------------\n\nWhen merging selectors, @extend is smart enough to avoid unnecessary duplication, so something like .seriousError.seriousError gets translated to .seriousError. In addition, it won\u2019t produce selectors that can\u2019t match anything, like #main#footer.\n\nExtending Complex Selectors\n\nClass selectors aren\u2019t the only things that can be extended. It\u2019s possible to extend any selector involving only a single element, such as .special.cool, a:hover, or a.user[href^=\"http://\"]. \nFor example:\n--------------------------------------------------------\n.hoverlink {\n  @extend a:hover;\n}\n--------------------------------------------------------\n\nJust like with classes, this means that all styles defined for a:hover are also applied to .hoverlink. \nFor example:\n--------------------------------------------------------\n.hoverlink {\n  @extend a:hover;\n}\na:hover {\n  text-decoration: underline;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\na:hover, .hoverlink {\n  text-decoration: underline; }\n--------------------------------------------------------\n\nJust like with .error.intrusion above, any rule that uses a:hover will also work for .hoverlink, even if they have other selectors as well. \nFor example:\n--------------------------------------------------------\n.hoverlink {\n  @extend a:hover;\n}\n.comment a.user:hover {\n  font-weight: bold;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n.comment a.user:hover, .comment .user.hoverlink {\n  font-weight: bold; }\n--------------------------------------------------------\n\n Try sassme @extend-multi for multiple extends';

var out_atextendmulti = 'Multiple Extends\n\nA single selector can extend more than one selector. This means that it inherits the styles of all the extended selectors. \nFor example:\n--------------------------------------------------------\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.attention {\n  font-size: 3em;\n  background-color: #ff0;\n}\n.seriousError {\n  @extend .error;\n  @extend .attention;\n  border-width: 3px;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n.error, .seriousError {\n  border: 1px #f00;\n  background-color: #fdd; }\n\n.attention, .seriousError {\n  font-size: 3em;\n  background-color: #ff0; }\n\n.seriousError {\n  border-width: 3px; }\n--------------------------------------------------------\n\nIn effect, every element with class .seriousError also has class .error and class .attention. Thus, the styles defined later in the document take precedence: .seriousError has background color #ff0 rather than #fdd, since .attention is defined later than .error.\n\nMultiple extends can also be written using a comma-separated list of selectors. For example, @extend .error, .attention is the same as @extend .error; @extend.attention.\n\nChaining Extends\n\nIt\u2019s possible for one selector to extend another selector that in turn extends a third. \nFor example:\n--------------------------------------------------------\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n.criticalError {\n  @extend .seriousError;\n  position: fixed;\n  top: 10%;\n  bottom: 10%;\n  left: 10%;\n  right: 10%;\n}\n--------------------------------------------------------\n\nNow everything with class .seriousError also has class .error, and everything with class .criticalError has class .seriousError and class .error. \nIt\u2019s compiled to:\n--------------------------------------------------------\n.error, .seriousError, .criticalError {\n  border: 1px #f00;\n  background-color: #fdd; }\n\n.seriousError, .criticalError {\n  border-width: 3px; }\n\n.criticalError {\n  position: fixed;\n  top: 10%;\n  bottom: 10%;\n  left: 10%;\n  right: 10%; }\n--------------------------------------------------------\n';

var out_selectorseq = 'Selector Sequences\n\nSelector sequences, such as .foo .bar or .foo + .bar, currently can\u2019t be extended. However, it is possible for nested selectors themselves to use @extend. \nFor example:\n--------------------------------------------------------\n#fake-links .link {\n  @extend a;\n}\n\na {\n  color: blue;\n  &:hover {\n    text-decoration: underline;\n  }\n}\n--------------------------------------------------------\n\nis compiled to\n--------------------------------------------------------\na, #fake-links .link {\n  color: blue; }\n  a:hover, #fake-links .link:hover {\n    text-decoration: underline; }\n--------------------------------------------------------\n\nMerging Selector Sequences\n\nSometimes a selector sequence extends another selector that appears in another sequence. In this case, the two sequences need to be merged. \nFor example:\n--------------------------------------------------------\n#admin .tabbar a {\n  font-weight: bold;\n}\n#demo .overview .fakelink {\n  @extend a;\n}\n--------------------------------------------------------\n\nWhile it would technically be possible to generate all selectors that could possibly match either sequence, this would make the stylesheet far too large. The simple example above, for instance, would require ten selectors. Instead, Sass generates only selectors that are likely to be useful.\n\nWhen the two sequences being merged have no selectors in common, then two new selectors are generated: one with the first sequence before the second, and one with the second sequence before the first. \nFor example:\n--------------------------------------------------------\n#admin .tabbar a {\n  font-weight: bold;\n}\n#demo .overview .fakelink {\n  @extend a;\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\n#admin .tabbar a,\n#admin .tabbar #demo .overview .fakelink,\n#demo .overview #admin .tabbar .fakelink {\n  font-weight: bold; }\n--------------------------------------------------------\n\nIf the two sequences do share some selectors, then those selectors will be merged together and only the differences (if any still exist) will alternate. In this example, both sequences contain the id #admin, so the resulting selectors will merge those two ids:\n\n--------------------------------------------------------\n#admin .tabbar a {\n  font-weight: bold;\n}\n#admin .overview .fakelink {\n  @extend a;\n}\n--------------------------------------------------------\n\nThis is compiled to:\n--------------------------------------------------------\n#admin .tabbar a,\n#admin .tabbar .overview .fakelink,\n#admin .overview .tabbar .fakelink {\n  font-weight: bold; }\n--------------------------------------------------------\n';

var out_atextendonly = '@extend-Only Selectors\n\nSometimes you\u2019ll write styles for a class that you only ever want to @extend, and never want to use directly in your HTML. This is especially true when writing a Sass library, where you may provide styles for users to @extend if they need and ignore if they don\u2019t.\n\nIf you use normal classes for this, you end up creating a lot of extra CSS when the stylesheets are generated, and run the risk of colliding with other classes that are being used in the HTML. That\u2019s why Sass supports \u201cplaceholder selectors\u201d (for example, %foo).\n\nPlaceholder selectors look like class and id selectors, except the # or . is replaced by %. They can be used anywhere a class or id could, and on their own they prevent rulesets from being rendered to CSS. For example:\n--------------------------------------------------------\n// This ruleset won\'t be rendered on its own.\n#context a%extreme {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em;\n}\n--------------------------------------------------------\n\nHowever, placeholder selectors can be extended, just like classes and ids. The extended selectors will be generated, but the base placeholder selector will not. \nFor example:\n--------------------------------------------------------\n.notice {\n  @extend %extreme;\n}\n--------------------------------------------------------\n\nIs compiled to:\n--------------------------------------------------------\n#context a.notice {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em; }\n--------------------------------------------------------';

var out_atextendoptional = 'The !optional Flag\n\nNormally when you extend a selector, it\u2019s an error if that @extend doesn\u2019t work. For example, if you write a.important {@extend .notice}, it\u2019s an error if there are no selectors that contain .notice. It\u2019s also an error if the only selector containing .notice is h1.notice, since h1 conflicts with a and so no new selector would be generated.\n\nSometimes, though, you want to allow an @extend not to produce any new selectors. To do so, just add the !optional flag after the selector. \nFor example:\n--------------------------------------------------------\na.important {\n  @extend .notice !optional;\n}\n--------------------------------------------------------';

var out_atextenddirective = '@extend in Directives\n\nThere are some restrictions on the use of @extend within directives such as @media. Sass is unable to make CSS rules outside of the @media block apply to selectors inside it without creating a huge amount of stylesheet bloat by copying styles all over the place. This means that if you use @extend within @media (or other CSS directives), you may only extend selectors that appear within the same directive block.\n\nFor example, the following works fine:\n--------------------------------------------------------\n@media print {\n  .error {\n    border: 1px #f00;\n    background-color: #fdd;\n  }\n  .seriousError {\n    @extend .error;\n    border-width: 3px;\n  }\n}\n--------------------------------------------------------\n\nBut this is an error:\n--------------------------------------------------------\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n\n@media print {\n  .seriousError {\n    // INVALID EXTEND: .error is used outside of the \"@media print\" directive\n    @extend .error;\n    border-width: 3px;\n  }\n}\n--------------------------------------------------------\n\nSomeday we hope to have @extend supported natively in the browser, which will allow it to be used within @media and other directives.';

var out_atroot = '@at-root\n\nThe @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector:\n--------------------------------------------------------\n.parent {\n  @at-root .child { ... }\n}\n--------------------------------------------------------\n\nor with a block containing multiple selectors:\n--------------------------------------------------------\n.parent {\n  @at-root {\n    .child1 { ... }\n    .child2 { ... }\n  }\n}\n--------------------------------------------------------\n\nThese produce, respectively:\n--------------------------------------------------------\n.parent { ... }\n\n.child1 { ... }\n.child2 { ... }\n--------------------------------------------------------\n\n\n\n@at-root (without: ...) and @at-root (with: ...)\n\nBy default, @at-root just excludes selectors. However, it\u2019s also possible to use @at-root to move outside of nested directives such as @media as well. \nFor example:\n--------------------------------------------------------\n@media print {\n  .page {\n    width: 8in;\n    @at-root (without: media) {\n      color: red;\n    }\n  }\n}\n--------------------------------------------------------\n\nproduces:\n--------------------------------------------------------\n@media print {\n  .page {\n    width: 8in;\n  }\n}\n.page {\n  color: red;\n}\n--------------------------------------------------------\n\nYou can use @at-root (without: ...) to move outside of any directive. You can also do it with multiple directives separated by a space: @at-root (without: media supports) moves outside of both @media and @supports queries.\n\nThere are two special values you can pass to @at-root. \u201crule\u201d refers to normal CSS rules; @at-root (without: rule) is the same as @at-root with no query. @at-root (without: all) means that the styles should be moved outside of all directives and CSS rules.\n\nIf you want to specify which directives or rules to include, rather than listing which ones should be excluded, you can use with instead of without. For example, @at-root (with: rule) will move outside of all directives, but will preserve any CSS rules.';

var out_atdebug = '@debug\n\nThe @debug directive prints the value of a SassScript expression to the standard error output stream. It\u2019s useful for debugging Sass files that have complicated SassScript going on. \nFor example:\n--------------------------------------------------------\n@debug 10em + 12em;\n--------------------------------------------------------\n\noutputs:\n--------------------------------------------------------\nLine 1 DEBUG: 22em\n--------------------------------------------------------';

var out_atwarn = '@warn\n\nThe @warn directive prints the value of a SassScript expression to the standard error output stream. It\u2019s useful for libraries that need to warn users of deprecations or recovering from minor mixin usage mistakes. There are two major distinctions between @warn and @debug:\n\nYou can turn warnings off with the --quiet command-line option or the :quiet Sass option.\nA stylesheet trace will be printed out along with the message so that the user being warned can see where their styles caused the warning.\nUsage Example:\n--------------------------------------------------------\n@mixin adjust-location($x, $y) {\n  @if unitless($x) {\n    @warn \"Assuming #{$x} to be in pixels\";\n    $x: 1px * $x;\n  }\n  @if unitless($y) {\n    @warn \"Assuming #{$y} to be in pixels\";\n    $y: 1px * $y;\n  }\n  position: relative; left: $x; top: $y;\n}\n--------------------------------------------------------\n';
var out_if ='if()\n\nThe built-in if() function allows you to branch on a condition and returns only one of two possible outcomes. It can be used in any script context. The if function only evaluates the argument corresponding to the one that it will return \u2013 this allows you to refer to variables that may not be defined or to have calculations that would otherwise cause an error (E.g. divide by zero).\n\n';

var out_atif = '@if\n\nThe @if directive takes a SassScript expression and uses the styles nested beneath it if the expression returns anything other than false or null:\n\n--------------------------------------------------------\np {\n  @if 1 + 1 == 2 { border: 1px solid;  }\n  @if 5 < 3      { border: 2px dotted; }\n  @if null       { border: 3px double; }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  border: 1px solid; }\n--------------------------------------------------------\n\n\nThe @if statement can be followed by several @else if statements and one @else statement. If the @if statement fails, the @else if statements are tried in order until one succeeds or the @else is reached. \nFor example:\n--------------------------------------------------------\n$type: monster;\np {\n  @if $type == ocean {\n    color: blue;\n  } @else if $type == matador {\n    color: red;\n  } @else if $type == monster {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n--------------------------------------------------------\n\nis compiled to:\n--------------------------------------------------------\np {\n  color: green; }\n--------------------------------------------------------';



program
  .version('0.0.1')
  .option('open', 'Open the Sass Docs Website')
  .option('nesting', 'Simple example of nesting')
  .option('nested-properties', 'Nested properties')
  .option('nested-rules', 'Nested rules')
  .option('parent', 'Parent Selectors: &')
  .option('placeholders', 'Placeholder Selectors: %meow')
  .option('comments', 'Comments: /* */ and //')
  .option('sass-shell', 'SassScript Shell')
  .option('variables', 'What are variables')
  .option('datatypes', 'Overview of 6 Sass data types')
  .option('string', 'String data type')
  .option('map', 'Map data type')
  .option('list', 'List data type')
  .option('color', 'Color data type')
  .option('operation', 'Sass operations overview')
  .option('color-operation', 'Color operations')
  .option('number-operation', 'Number operations')
  .option('string-operation', 'String operations')
  .option('list-operation', 'List operations')
  .option('bool-operation', 'Boolean operations')
  .option('parenthesis', 'These things: ()')
  .option('functions', 'Cool Sass functions')
  .option('interpolation', '#{} interpolation syntax')
  .option('defaults', 'Variable defaults: !default')
  .option('@rules', 'A list of Sass @rules')
  .option('@import', 'Import Scss/Sass files')
  .option('@import-partials', 'Files prepended with: "_"')
  .option('@import-nested', 'Import within CSS and @media rules')
  .option('@media', '@media directives')
  .option('@extend', '@extending styles')
  .option('@extend-only', '@extend-only selectors')
  .option('@extend-multi', 'Using multiple extends')
  .option('@extend-optional', '@extend !optional flag')
  .option('@extend-directive', 'Using @extends in directives')
  .option('selector-sequence', 'Selector sequences')
  .option('@at-root', '@at-root directive')
  .option('@debug', '@debug directive')
  .option('@warn', '@warn directive')
  .option('if', 'if() function')
  .option('@if', '@if directive')
  .parse(process.argv);

function readSassMe () {
	
// get the arguments, minus node
	var args = process.argv.slice(2).toString();

	if (args == 'nesting') {
		console.log(out_nesting);
	}	

	else if (args == 'nested-properties') {
		console.log(out_nestedprops);
	}

	else if (args == 'nested-rules') {
		console.log(out_nestedrules);
	}

	else if (['parents', 'parent', 'parent-selectors', 'parent-selector'].indexOf(args) > -1) {
		console.log(out_parent);
	}

	else if (['vars', 'variables', 'variable'].indexOf(args) > -1) {
		console.log(out_vars);
	}

	else if (['placeholder', 'placeholders'].indexOf(args) > -1) {
		console.log(out_placeholders);
	}

	else if (['comment', 'comments'].indexOf(args) > -1) {
		console.log(out_comments);
	}

	else if (['datatypes', 'data-types'].indexOf(args) > -1) {
		console.log(out_datatype);
	}

	else if (['string', 'strings'].indexOf(args) > -1) {
		console.log(out_string);
	}

	else if (['map', 'maps'].indexOf(args) > -1) {
		console.log(out_map);
	}

	else if (['list', 'lists'].indexOf(args) > -1) {
		console.log(out_list);
	}

	else if (['color', 'colors'].indexOf(args) > -1) {
		console.log(out_color);
	}

	else if (['operation', 'operations'].indexOf(args) > -1) {
		console.log(out_operation);
	}

	else if (['number-operation', 'number-operations'].indexOf(args) > -1) {
		console.log(out_numberoperation);
	}

	else if (['color-operation', 'color-operations'].indexOf(args) > -1) {
		console.log(out_coloroperation);
	}

	else if (['string-operation', 'string-operations'].indexOf(args) > -1) {
		console.log(out_stringoperation);
	}

	else if (['list-operation', 'list-operations'].indexOf(args) > -1) {
		console.log(out_listoperation);
	}

	else if (['bool-operation', 'bool-operations', 'boolean-operation', 'boolean-operations'].indexOf(args) > -1) {
		console.log(out_booleanoperation);
	}

	else if (['sass-shell', 'sassscript', 'sass-script', 'sass-script-shell', 'shell'].indexOf(args) > -1) {
		console.log(out_shell);
	}

	else if (args == 'parenthesis') {
		console.log(out_parenthesis);
	}

	else if (args == 'if') {
		console.log(out_if);
	}

	else if (args == 'open') {
		open('http://sass-lang.com/documentation/file.SASS_REFERENCE.html'); //causing error
	}

	else if (['function', 'functions'].indexOf(args) > -1) {
		console.log(out_functions);
	}

	else if (['interpolation'].indexOf(args) > -1) {
		console.log(out_interpolation);
	}

	else if (['default', 'defaults'].indexOf(args) > -1) {
		console.log(out_default);
	}

	else if (['selector-sequence', 'selector-sequences', 'selectorsequence', 'selectorsequences'].indexOf(args) > -1) {
		console.log(out_selectorseq);
	}

	else if (['@-rules', '@rules', 'at-rules'].indexOf(args) > -1) {
		console.log(out_atrules);
	}

	else if (['media', '@-media', '@media', 'at-media'].indexOf(args) > -1) {
		console.log(out_atmedia);
	}

	else if (['import', '@-import', '@import', 'at-import'].indexOf(args) > -1) {
		console.log(out_atimport);
	}

	else if (['atroot', 'at-root', '@-atroot', '@atroot', 'at-atroot', '@-at-root', '@at-root', 'at-at-root'].indexOf(args) > -1) {
		console.log(out_atroot);
	}

	else if (['extend', '@-extend', '@extend', 'at-extend'].indexOf(args) > -1) {
		console.log(out_atextend);
	}

	else if (['debug', '@-debug', '@debug', 'at-debug'].indexOf(args) > -1) {
		console.log(out_atdebug);
	}

	else if (['warn', '@-warn', '@warn', 'at-warn'].indexOf(args) > -1) {
		console.log(out_atwarn);
	}

	else if (['@-extendonly', '@extendonly', 'at-extendonly', '@-extend-only', '@extend-only', 'at-extend-only'].indexOf(args) > -1) {
		console.log(out_atextendonly);
	}

	else if (['@-extendoptional', '@extendoptional', 'at-extendoptional', '@-extend-optional', '@extend-optional', 'at-extend-optional'].indexOf(args) > -1) {
		console.log(out_atextendoptional);
	}

	else if (['@-extend-multi', '@extend-multi', 'at-extendmulti'].indexOf(args) > -1) {
		console.log(out_atextendmulti);
	}

	else if (['@importnested', '@import-nested', 'at-import-nested'].indexOf(args) > -1) {
		console.log(out_atimportnest);
	}

	else if (['@-import-partials', '@importpartials', 'at-import-partials'].indexOf(args) > -1) {
		console.log(out_atimportpart);
	}

	else {
		console.log(error);
	}
};

readSassMe();